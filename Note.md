slf4j
- 로깅을 위한 인터페이스의 모음
- LogBack, log4j와 같은 구현체들이 있음

## JPA
#### 모든 연관관계는 지연 로딩으로 설정하자! 💛
- 즉시로딩(`EAGER`)은 예측이 어렵고 어떤 SQL이 실행될지 추적하기 어렵다. 특히 `JPQL`을 실행할 때 `N+1` 문제가 자주 발생한다.
- 연관된 엔티티를 함께 DB에서 조회해야 하면, 즉시로딩(`EAGER`)로 설정하기 보다 **fetch join** 또는 **엔티티 그래프 기능**을 사용하자.
- `@ManyToOne`, `@OneToOne`은 즉시로딩이 default.


#### Entity Manager Factory와 EntityManager 💓
- EntityManagerFactory는 EntityManager를 만드는 역할을 한다.
- EntityManagerFactory를 만드는 비용은 상당히 크다.
- 여러 스레드가 동시에 접근해도 안전하다.
- EntityManager는 엔티티를 수정/삭제/조회 등 일을 처리하는데, 말 그대로 엔티티 관리자 이다.
- EntityManager를 생성하는 비용은 거의 들지 않지만, 스레드가 동시 접근하면 동시성 문제가 발생하여 스레드 간 절대 공유해서는 안된다.


- EntityManager는 트랜잭션이 시작할 때와 같이 db 연결이 꼭 필요한 시점에 데이터베이스 커넥션을 획득한다.
- EntityManagerFactory를 생성하는 시점에 데이터베이스 커넥션풀도 생성한다.
---

#### 영속성 컨텍스트 (Persistence Context) 🤍
- 엔티티를 '영구 저장'하는 환경이라는 뜻으로, 엔티티 매니저로 엔티티를 저장하거나 조회 시, 영속성 컨텍스트에 엔티티를 보관하고 관리한다.
- 아래 코드는 엔티티 매니저가 엔티티를 영속성 컨텍스트에 저장하는 코드이다.
`EntityManager객체.persist(엔티티)`
- 여러 엔티티 매니저가 같은 영속성 컨텍스트에 접근할 수도, 하나의 엔티티 매니저에 하나의 영속성 먼텍스트가 생성될 수도 있다.

- 특징
1. 영속성 컨텍스트는 엔티티를 식별자값으로 구분하기 때문에 식별자 값이 반드시 있어야 한다. (안그러면 예외 발생)
2. 영속성 컨텍스트에 새로 저장된 엔티티는 트랜잭션을 커밋하는 순간 DB에 flush된다.
- 장점
1. 1차 캐시
- 영속성 컨텍스트 내부에 (식별자,엔티티 인스턴스) 형태로 Map 자료구조로 존재하는 캐시 공간
- 1차 캐시에 존재하지 않으면, DB에서 가져와서 1차 캐시에 저장한 후 반환한다.
2. 동일성 보장
- 조회 시 1차 캐시에 저장된 엔티티들을 조회하기 때문에 같은 엔티티가 조회되므로 동일성이 보장된다.
3. 트랜잭션을 지원하는 쓰기 지연(Lazy)
4. 변경 감지
- 엔티티가 처음 1차 캐시에 저장될 때 JPA는 최초 상태를 복사해서 저장해둔다. (스냅샷)
- (플러시 시점) 트랜잭션이 커밋될 때마다 그 스냅샷과 엔티티를 비교해서 변경된 엔티티를 찾는다.  (영속 상태의 엔티티에만 적용)
- 있다면 update sql문을 생성해서 **쓰기 지연 SQL 저장소**에 보낸다. 이 저장소의 SQL을 DB에 보낸다.
- DB 트랜잭션을 커밋(플러시)한다. 이때 모든 필드가 다시 update된다. (BUT, 일부 필드만 업데이트되는 게 더 장점인 상황이라면 전략을 수정하면 된다.)
- 일부 필드만 변경되기 원하면 `@org.hibernate.annotations.DynamicUpdate`
5. 지연 로딩
---

#### 플러시(flush()) 💜
- 영속성 컨텍스트의 변경 내용을 DB에 반영한다.
- 영속성 컨텍스트를 플러시하는 방법 3가지
1. 직접 호출 : `em.flush()`
- 거의 사용 X
2. 트랜잭션 커밋 시 플러시가 자동 호출
-  플러시를 통해 영속성 컨텍스트의 변경 내용을 SQL로 전달하고 트랜잭션을 커밋해야 데이터베이스에 반영이 된다.
-  그래서 트랜잭션 커밋 시 자동으로 플러시를 호출한다.
3. JPQL 쿼리 실행 시 플러시가 자동 호출
- 만약 memeberA, memeberB, memeberC를 영속성 컨텍스트에 저장(`em.persist(멤버)`)했는데, 플러시 없이 바로 JPQL문을 날리면 어떻게 될까?
```java
em.creqteQuery('select m from Member m', Member.class);
```
- 세 엔티티에 대한 정보는 아직 DB에 반영되지 않았으므로 조회되지 않을 것이다.
- 그래서 JPQL 실행 시 플러시가 자동으로 호출된다.
- 단, 식별자를 기준으로 조회하는 `find()` 메서드 실행 시에는 플러시가 호출되지 않는다.    **영속성 컨텍스트에서 조회해서 그런가?**
---

#### 준영속 상태(detached)의 엔티티 🧡
-영속성 컨텍스트가 관리하던 엔티티가 영속성 컨텍스트에서 분리되는 것을 준영속 상태라고 한다.
- 3가지 방법으로 준영속 상태로 만들 수 있다.
1. 특정 엔티티만 준영속 상태로 전환 : `em.detach(엔티티)`  -> 1차 캐시와 SQL 쓰기 저장소에 있는 정보 모두 삭제
2. 영속성 컨텍스트를 완전히 초기화 : `em.clear()`
3. 영속성 컨텍스트를 종료 : `em.close()`
- 특징
1. 영속성 컨텍스트가 제공하는 기능을 하나도 지원받지 못한다. (1차 캐시, 쓰기 지연, 변경 감지, 지연 로딩)
2. (비영속 상태와 달리) 식별자 값은 가지고 있다. (이미 한번 영속 상태였으므로)
3. 지연 로딩은 실제 객체 대신 프록시 객체를 로딩해두고 해당 객체를 실제로 사용할 때 영속성 컨텍스트를 통해 데이터를 불러오는 방법인데,
준 영속 상태는 영속성 컨텍스트가 더이상 관리하지 않으므로 지연 로딩 시 문제가 발생한다.
---

#### 어노테이션을 이용한 객체와 테이블 매핑 💜
- JPA는 엔티티 객체를 생성할 때 기본 생성자를 사용하기 때문에, 만약 생성자를 하나 이상 만드는 경우 기본 생성자를 직접 만들어 놔야한다. (`public` 또는 `protected`)
- **DB 스키마 자동 생성** 속성은 운영환경보다, 테스트 환경이나 엔티티와 테이블을 어떻게 매핑해야하는지 학습하는 용도로만 사용하자. (훌륭한 학습 도구!)
  - create, create-drop, update, validate, none 
- 유니크 제약조건을 걸어주는 `uniqueConstraints` 속성
  - DDL 생성 시 유니크 제약조건이 추가된다.
```java
@Table(name="MEMBER", uniqueConstraints = {@UniqueConstraint(
  name = "NAME_AGE_UNIQUE",
  columnNames = {"NAME", "AGE"} )})
```
생성된 DDL
```sql
ALTER TABLE MEMBER ADD CONSTRAINT NAME_AGE_UNIQUE UNIQUE (NAME, AGE)
```
---

#### 기본키 직접 할당 전략 💙
`@Id` 로 매핑하여 기본 키를 직접 할당할 수 있다.
적용 가능한 타입은 아래와 같다.
- 자바 기본형
- 자바 Wrapper 형
- String
- java.util.Date
- java.sql.Date
- java.math.BigDecimal
- java.math.BigInteger
---

### IDENTITY 전략과 SEQUENCE 전략 🤎
```
IDENTITY 전략은 데이터를 DB에 INSERT한 후 기본 키 값을 조회할 수 있기 때문에, 추가로 DB를 조회해서 엔티티에 식별자 값을 할당할 수 있었다. 
하지만 JDBC3에 추가된 `Statement.getGeneratedKeys()`를 사용하면 데이터 저장과 동시에 생성된 기본키 값도 얻어올 수 있어 한번만 통신할 수 있게 된다.
```
엔티티가 영속 상태가 되려면 식별자가 반드시 필요하므로 em.persist()`를 호출하는 즉시 INSERT SQL이 db에 전달되어 식별자를 얻는다. 즉, 쓰기 지연이 동작하지 않는 전략이다.
